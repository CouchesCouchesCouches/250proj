//
// Generated file, do not edit! Created by nedtool 5.6 from classical_messages.msg.
//

#ifndef __QUISP__MESSAGES_CLASSICAL_MESSAGES_M_H
#define __QUISP__MESSAGES_CLASSICAL_MESSAGES_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
    #include <vector>
    #include <unsupported/Eigen/MatrixFunctions>

	using namespace omnetpp;
    typedef cModule *GOD_statQubitPtr;
// }}

// cplusplus {{
#include <rules/RuleSet.h>
#include <modules/QNIC.h>
typedef quisp::modules::QNIC_id_pair QNIC_pair_info;
// }}


namespace quisp {
namespace messages {

/**
 * Class generated from <tt>classical_messages.msg:23</tt> by nedtool.
 * <pre>
 * packet deleteThisModule
 * {
 * }
 * </pre>
 */
class deleteThisModule : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const deleteThisModule& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const deleteThisModule&);

  public:
    deleteThisModule(const char *name=nullptr, short kind=0);
    deleteThisModule(const deleteThisModule& other);
    virtual ~deleteThisModule();
    deleteThisModule& operator=(const deleteThisModule& other);
    virtual deleteThisModule *dup() const override {return new deleteThisModule(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const deleteThisModule& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, deleteThisModule& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:26</tt> by nedtool.
 * <pre>
 * packet header
 * {
 *     int srcAddr;
 *     int destAddr;
 *     int hopCount;
 * }
 * </pre>
 */
class header : public ::omnetpp::cPacket
{
  protected:
    int srcAddr;
    int destAddr;
    int hopCount;

  private:
    void copy(const header& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const header&);

  public:
    header(const char *name=nullptr, short kind=0);
    header(const header& other);
    virtual ~header();
    header& operator=(const header& other);
    virtual header *dup() const override {return new header(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getSrcAddr() const;
    virtual void setSrcAddr(int srcAddr);
    virtual int getDestAddr() const;
    virtual void setDestAddr(int destAddr);
    virtual int getHopCount() const;
    virtual void setHopCount(int hopCount);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const header& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, header& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:34</tt> by nedtool.
 * <pre>
 * packet ConnectionSetupRequest extends header
 * {
 *     int actual_destAddr;
 *     int actual_srcAddr;
 * 
 *     int num_measure;
 * 
 *     int number_of_required_Bellpairs;
 *     double required_fidelity;
 * 
 *     int stack_of_QNodeIndexes[];
 *     int stack_of_linkCosts[];
 * 
 *     QNIC_pair_info stack_of_QNICs[];
 * }
 * </pre>
 */
class ConnectionSetupRequest : public ::quisp::messages::header
{
  protected:
    int actual_destAddr;
    int actual_srcAddr;
    int num_measure;
    int number_of_required_Bellpairs;
    double required_fidelity;
    int *stack_of_QNodeIndexes; // array ptr
    unsigned int stack_of_QNodeIndexes_arraysize;
    int *stack_of_linkCosts; // array ptr
    unsigned int stack_of_linkCosts_arraysize;
    QNIC_pair_info *stack_of_QNICs; // array ptr
    unsigned int stack_of_QNICs_arraysize;

  private:
    void copy(const ConnectionSetupRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ConnectionSetupRequest&);

  public:
    ConnectionSetupRequest(const char *name=nullptr, short kind=0);
    ConnectionSetupRequest(const ConnectionSetupRequest& other);
    virtual ~ConnectionSetupRequest();
    ConnectionSetupRequest& operator=(const ConnectionSetupRequest& other);
    virtual ConnectionSetupRequest *dup() const override {return new ConnectionSetupRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getActual_destAddr() const;
    virtual void setActual_destAddr(int actual_destAddr);
    virtual int getActual_srcAddr() const;
    virtual void setActual_srcAddr(int actual_srcAddr);
    virtual int getNum_measure() const;
    virtual void setNum_measure(int num_measure);
    virtual int getNumber_of_required_Bellpairs() const;
    virtual void setNumber_of_required_Bellpairs(int number_of_required_Bellpairs);
    virtual double getRequired_fidelity() const;
    virtual void setRequired_fidelity(double required_fidelity);
    virtual void setStack_of_QNodeIndexesArraySize(unsigned int size);
    virtual unsigned int getStack_of_QNodeIndexesArraySize() const;
    virtual int getStack_of_QNodeIndexes(unsigned int k) const;
    virtual void setStack_of_QNodeIndexes(unsigned int k, int stack_of_QNodeIndexes);
    virtual void setStack_of_linkCostsArraySize(unsigned int size);
    virtual unsigned int getStack_of_linkCostsArraySize() const;
    virtual int getStack_of_linkCosts(unsigned int k) const;
    virtual void setStack_of_linkCosts(unsigned int k, int stack_of_linkCosts);
    virtual void setStack_of_QNICsArraySize(unsigned int size);
    virtual unsigned int getStack_of_QNICsArraySize() const;
    virtual QNIC_pair_info& getStack_of_QNICs(unsigned int k);
    virtual const QNIC_pair_info& getStack_of_QNICs(unsigned int k) const {return const_cast<ConnectionSetupRequest*>(this)->getStack_of_QNICs(k);}
    virtual void setStack_of_QNICs(unsigned int k, const QNIC_pair_info& stack_of_QNICs);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ConnectionSetupRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ConnectionSetupRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:50</tt> by nedtool.
 * <pre>
 * packet RejectConnectionSetupRequest extends header
 * {
 *     int actual_destAddr;
 *     int actual_srcAddr;
 *     int number_of_required_Bellpairs;
 * }
 * </pre>
 */
class RejectConnectionSetupRequest : public ::quisp::messages::header
{
  protected:
    int actual_destAddr;
    int actual_srcAddr;
    int number_of_required_Bellpairs;

  private:
    void copy(const RejectConnectionSetupRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RejectConnectionSetupRequest&);

  public:
    RejectConnectionSetupRequest(const char *name=nullptr, short kind=0);
    RejectConnectionSetupRequest(const RejectConnectionSetupRequest& other);
    virtual ~RejectConnectionSetupRequest();
    RejectConnectionSetupRequest& operator=(const RejectConnectionSetupRequest& other);
    virtual RejectConnectionSetupRequest *dup() const override {return new RejectConnectionSetupRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getActual_destAddr() const;
    virtual void setActual_destAddr(int actual_destAddr);
    virtual int getActual_srcAddr() const;
    virtual void setActual_srcAddr(int actual_srcAddr);
    virtual int getNumber_of_required_Bellpairs() const;
    virtual void setNumber_of_required_Bellpairs(int number_of_required_Bellpairs);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const RejectConnectionSetupRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, RejectConnectionSetupRequest& obj) {obj.parsimUnpack(b);}

// cplusplus {{
    typedef quisp::rules::RuleSet * RuleSetField;
// }}

/**
 * Class generated from <tt>classical_messages.msg:64</tt> by nedtool.
 * <pre>
 * packet LinkTomographyRuleSet extends header
 * {
 *     int process_id;
 *     int number_of_measuring_resources;
 *     RuleSetField RuleSet;
 * }
 * </pre>
 */
class LinkTomographyRuleSet : public ::quisp::messages::header
{
  protected:
    int process_id;
    int number_of_measuring_resources;
    RuleSetField RuleSet;

  private:
    void copy(const LinkTomographyRuleSet& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LinkTomographyRuleSet&);

  public:
    LinkTomographyRuleSet(const char *name=nullptr, short kind=0);
    LinkTomographyRuleSet(const LinkTomographyRuleSet& other);
    virtual ~LinkTomographyRuleSet();
    LinkTomographyRuleSet& operator=(const LinkTomographyRuleSet& other);
    virtual LinkTomographyRuleSet *dup() const override {return new LinkTomographyRuleSet(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getProcess_id() const;
    virtual void setProcess_id(int process_id);
    virtual int getNumber_of_measuring_resources() const;
    virtual void setNumber_of_measuring_resources(int number_of_measuring_resources);
    virtual RuleSetField& getRuleSet();
    virtual const RuleSetField& getRuleSet() const {return const_cast<LinkTomographyRuleSet*>(this)->getRuleSet();}
    virtual void setRuleSet(const RuleSetField& RuleSet);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LinkTomographyRuleSet& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LinkTomographyRuleSet& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:71</tt> by nedtool.
 * <pre>
 * packet LinkTomographyRequest extends header
 * {
 * }
 * </pre>
 */
class LinkTomographyRequest : public ::quisp::messages::header
{
  protected:

  private:
    void copy(const LinkTomographyRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LinkTomographyRequest&);

  public:
    LinkTomographyRequest(const char *name=nullptr, short kind=0);
    LinkTomographyRequest(const LinkTomographyRequest& other);
    virtual ~LinkTomographyRequest();
    LinkTomographyRequest& operator=(const LinkTomographyRequest& other);
    virtual LinkTomographyRequest *dup() const override {return new LinkTomographyRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LinkTomographyRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LinkTomographyRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:75</tt> by nedtool.
 * <pre>
 * packet LinkTomographyAck extends header
 * {
 *     QNIC_type qnic_type;
 *     int qnic_index;
 * }
 * </pre>
 */
class LinkTomographyAck : public ::quisp::messages::header
{
  protected:
    QNIC_type qnic_type;
    int qnic_index;

  private:
    void copy(const LinkTomographyAck& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LinkTomographyAck&);

  public:
    LinkTomographyAck(const char *name=nullptr, short kind=0);
    LinkTomographyAck(const LinkTomographyAck& other);
    virtual ~LinkTomographyAck();
    LinkTomographyAck& operator=(const LinkTomographyAck& other);
    virtual LinkTomographyAck *dup() const override {return new LinkTomographyAck(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual QNIC_type& getQnic_type();
    virtual const QNIC_type& getQnic_type() const {return const_cast<LinkTomographyAck*>(this)->getQnic_type();}
    virtual void setQnic_type(const QNIC_type& qnic_type);
    virtual int getQnic_index() const;
    virtual void setQnic_index(int qnic_index);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LinkTomographyAck& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LinkTomographyAck& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:81</tt> by nedtool.
 * <pre>
 * packet LinkTomographyResult extends header
 * {
 *     bool Output_is_plus;
 *     char Basis;
 *     int count_id;
 *     int partner_address;
 *     simtime_t finish = -1;
 *     int max_count;
 *     char GOD_clean;
 * }
 * </pre>
 */
class LinkTomographyResult : public ::quisp::messages::header
{
  protected:
    bool Output_is_plus;
    char Basis;
    int count_id;
    int partner_address;
    ::omnetpp::simtime_t finish;
    int max_count;
    char GOD_clean;

  private:
    void copy(const LinkTomographyResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const LinkTomographyResult&);

  public:
    LinkTomographyResult(const char *name=nullptr, short kind=0);
    LinkTomographyResult(const LinkTomographyResult& other);
    virtual ~LinkTomographyResult();
    LinkTomographyResult& operator=(const LinkTomographyResult& other);
    virtual LinkTomographyResult *dup() const override {return new LinkTomographyResult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getOutput_is_plus() const;
    virtual void setOutput_is_plus(bool Output_is_plus);
    virtual char getBasis() const;
    virtual void setBasis(char Basis);
    virtual int getCount_id() const;
    virtual void setCount_id(int count_id);
    virtual int getPartner_address() const;
    virtual void setPartner_address(int partner_address);
    virtual ::omnetpp::simtime_t getFinish() const;
    virtual void setFinish(::omnetpp::simtime_t finish);
    virtual int getMax_count() const;
    virtual void setMax_count(int max_count);
    virtual char getGOD_clean() const;
    virtual void setGOD_clean(char GOD_clean);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const LinkTomographyResult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, LinkTomographyResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:92</tt> by nedtool.
 * <pre>
 * packet PurificationResult extends header
 * {
 *     bool Output_is_plus;
 *     unsigned long ruleset_id;
 *     int rule_id;
 *     int action_index;
 *     GOD_statQubitPtr entangled_with;//For Debugging purposes.
 * }
 * </pre>
 */
class PurificationResult : public ::quisp::messages::header
{
  protected:
    bool Output_is_plus;
    unsigned long ruleset_id;
    int rule_id;
    int action_index;
    GOD_statQubitPtr entangled_with;

  private:
    void copy(const PurificationResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PurificationResult&);

  public:
    PurificationResult(const char *name=nullptr, short kind=0);
    PurificationResult(const PurificationResult& other);
    virtual ~PurificationResult();
    PurificationResult& operator=(const PurificationResult& other);
    virtual PurificationResult *dup() const override {return new PurificationResult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getOutput_is_plus() const;
    virtual void setOutput_is_plus(bool Output_is_plus);
    virtual unsigned long getRuleset_id() const;
    virtual void setRuleset_id(unsigned long ruleset_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int rule_id);
    virtual int getAction_index() const;
    virtual void setAction_index(int action_index);
    virtual GOD_statQubitPtr& getEntangled_with();
    virtual const GOD_statQubitPtr& getEntangled_with() const {return const_cast<PurificationResult*>(this)->getEntangled_with();}
    virtual void setEntangled_with(const GOD_statQubitPtr& entangled_with);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const PurificationResult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, PurificationResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:103</tt> by nedtool.
 * <pre>
 * packet DoublePurificationResult extends header
 * {
 *     bool ZOutput_is_plus;
 *     bool XOutput_is_plus;
 *     unsigned long ruleset_id;
 *     int rule_id;
 *     int action_index;
 *     GOD_statQubitPtr entangled_with;//For Debugging purposes.
 * }
 * </pre>
 */
class DoublePurificationResult : public ::quisp::messages::header
{
  protected:
    bool ZOutput_is_plus;
    bool XOutput_is_plus;
    unsigned long ruleset_id;
    int rule_id;
    int action_index;
    GOD_statQubitPtr entangled_with;

  private:
    void copy(const DoublePurificationResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DoublePurificationResult&);

  public:
    DoublePurificationResult(const char *name=nullptr, short kind=0);
    DoublePurificationResult(const DoublePurificationResult& other);
    virtual ~DoublePurificationResult();
    DoublePurificationResult& operator=(const DoublePurificationResult& other);
    virtual DoublePurificationResult *dup() const override {return new DoublePurificationResult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getZOutput_is_plus() const;
    virtual void setZOutput_is_plus(bool ZOutput_is_plus);
    virtual bool getXOutput_is_plus() const;
    virtual void setXOutput_is_plus(bool XOutput_is_plus);
    virtual unsigned long getRuleset_id() const;
    virtual void setRuleset_id(unsigned long ruleset_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int rule_id);
    virtual int getAction_index() const;
    virtual void setAction_index(int action_index);
    virtual GOD_statQubitPtr& getEntangled_with();
    virtual const GOD_statQubitPtr& getEntangled_with() const {return const_cast<DoublePurificationResult*>(this)->getEntangled_with();}
    virtual void setEntangled_with(const GOD_statQubitPtr& entangled_with);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DoublePurificationResult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DoublePurificationResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:115</tt> by nedtool.
 * <pre>
 * packet DS_DoublePurificationResult extends header
 * {
 *     bool ZOutput_is_plus;
 *     bool XOutput_is_plus;
 *     bool DS_ZOutput_is_plus;
 *     bool DS_XOutput_is_plus;
 *     unsigned long ruleset_id;
 *     int rule_id;
 *     int action_index;
 *     GOD_statQubitPtr entangled_with;//For Debugging purposes.
 * }
 * </pre>
 */
class DS_DoublePurificationResult : public ::quisp::messages::header
{
  protected:
    bool ZOutput_is_plus;
    bool XOutput_is_plus;
    bool DS_ZOutput_is_plus;
    bool DS_XOutput_is_plus;
    unsigned long ruleset_id;
    int rule_id;
    int action_index;
    GOD_statQubitPtr entangled_with;

  private:
    void copy(const DS_DoublePurificationResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DS_DoublePurificationResult&);

  public:
    DS_DoublePurificationResult(const char *name=nullptr, short kind=0);
    DS_DoublePurificationResult(const DS_DoublePurificationResult& other);
    virtual ~DS_DoublePurificationResult();
    DS_DoublePurificationResult& operator=(const DS_DoublePurificationResult& other);
    virtual DS_DoublePurificationResult *dup() const override {return new DS_DoublePurificationResult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getZOutput_is_plus() const;
    virtual void setZOutput_is_plus(bool ZOutput_is_plus);
    virtual bool getXOutput_is_plus() const;
    virtual void setXOutput_is_plus(bool XOutput_is_plus);
    virtual bool getDS_ZOutput_is_plus() const;
    virtual void setDS_ZOutput_is_plus(bool DS_ZOutput_is_plus);
    virtual bool getDS_XOutput_is_plus() const;
    virtual void setDS_XOutput_is_plus(bool DS_XOutput_is_plus);
    virtual unsigned long getRuleset_id() const;
    virtual void setRuleset_id(unsigned long ruleset_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int rule_id);
    virtual int getAction_index() const;
    virtual void setAction_index(int action_index);
    virtual GOD_statQubitPtr& getEntangled_with();
    virtual const GOD_statQubitPtr& getEntangled_with() const {return const_cast<DS_DoublePurificationResult*>(this)->getEntangled_with();}
    virtual void setEntangled_with(const GOD_statQubitPtr& entangled_with);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DS_DoublePurificationResult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DS_DoublePurificationResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:128</tt> by nedtool.
 * <pre>
 * packet DS_DoublePurificationSecondResult extends header
 * {
 *     bool ZOutput_is_plus;
 *     bool XOutput_is_plus;
 *     bool DS_Output_is_plus;
 *     unsigned long ruleset_id;
 *     int rule_id;
 *     int action_index;
 *     GOD_statQubitPtr entangled_with;//For Debugging purposes.
 * }
 * </pre>
 */
class DS_DoublePurificationSecondResult : public ::quisp::messages::header
{
  protected:
    bool ZOutput_is_plus;
    bool XOutput_is_plus;
    bool DS_Output_is_plus;
    unsigned long ruleset_id;
    int rule_id;
    int action_index;
    GOD_statQubitPtr entangled_with;

  private:
    void copy(const DS_DoublePurificationSecondResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DS_DoublePurificationSecondResult&);

  public:
    DS_DoublePurificationSecondResult(const char *name=nullptr, short kind=0);
    DS_DoublePurificationSecondResult(const DS_DoublePurificationSecondResult& other);
    virtual ~DS_DoublePurificationSecondResult();
    DS_DoublePurificationSecondResult& operator=(const DS_DoublePurificationSecondResult& other);
    virtual DS_DoublePurificationSecondResult *dup() const override {return new DS_DoublePurificationSecondResult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getZOutput_is_plus() const;
    virtual void setZOutput_is_plus(bool ZOutput_is_plus);
    virtual bool getXOutput_is_plus() const;
    virtual void setXOutput_is_plus(bool XOutput_is_plus);
    virtual bool getDS_Output_is_plus() const;
    virtual void setDS_Output_is_plus(bool DS_Output_is_plus);
    virtual unsigned long getRuleset_id() const;
    virtual void setRuleset_id(unsigned long ruleset_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int rule_id);
    virtual int getAction_index() const;
    virtual void setAction_index(int action_index);
    virtual GOD_statQubitPtr& getEntangled_with();
    virtual const GOD_statQubitPtr& getEntangled_with() const {return const_cast<DS_DoublePurificationSecondResult*>(this)->getEntangled_with();}
    virtual void setEntangled_with(const GOD_statQubitPtr& entangled_with);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const DS_DoublePurificationSecondResult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, DS_DoublePurificationSecondResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:138</tt> by nedtool.
 * <pre>
 * packet ConditionNotSatisfied
 * {
 * }
 * </pre>
 */
class ConditionNotSatisfied : public ::omnetpp::cPacket
{
  protected:

  private:
    void copy(const ConditionNotSatisfied& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ConditionNotSatisfied&);

  public:
    ConditionNotSatisfied(const char *name=nullptr, short kind=0);
    ConditionNotSatisfied(const ConditionNotSatisfied& other);
    virtual ~ConditionNotSatisfied();
    ConditionNotSatisfied& operator=(const ConditionNotSatisfied& other);
    virtual ConditionNotSatisfied *dup() const override {return new ConditionNotSatisfied(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ConditionNotSatisfied& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ConditionNotSatisfied& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:142</tt> by nedtool.
 * <pre>
 * packet ConnectionSetupResponse extends header
 * {
 *     int actual_srcAddr;
 *     int actual_destAddr;
 *     unsigned long RuleSet_id;
 *     RuleSetField RuleSet;
 *     int application_type;
 * 
 *     int stack_of_QNodeIndexes[];
 * }
 * </pre>
 */
class ConnectionSetupResponse : public ::quisp::messages::header
{
  protected:
    int actual_srcAddr;
    int actual_destAddr;
    unsigned long RuleSet_id;
    RuleSetField RuleSet;
    int application_type;
    int *stack_of_QNodeIndexes; // array ptr
    unsigned int stack_of_QNodeIndexes_arraysize;

  private:
    void copy(const ConnectionSetupResponse& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ConnectionSetupResponse&);

  public:
    ConnectionSetupResponse(const char *name=nullptr, short kind=0);
    ConnectionSetupResponse(const ConnectionSetupResponse& other);
    virtual ~ConnectionSetupResponse();
    ConnectionSetupResponse& operator=(const ConnectionSetupResponse& other);
    virtual ConnectionSetupResponse *dup() const override {return new ConnectionSetupResponse(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getActual_srcAddr() const;
    virtual void setActual_srcAddr(int actual_srcAddr);
    virtual int getActual_destAddr() const;
    virtual void setActual_destAddr(int actual_destAddr);
    virtual unsigned long getRuleSet_id() const;
    virtual void setRuleSet_id(unsigned long RuleSet_id);
    virtual RuleSetField& getRuleSet();
    virtual const RuleSetField& getRuleSet() const {return const_cast<ConnectionSetupResponse*>(this)->getRuleSet();}
    virtual void setRuleSet(const RuleSetField& RuleSet);
    virtual int getApplication_type() const;
    virtual void setApplication_type(int application_type);
    virtual void setStack_of_QNodeIndexesArraySize(unsigned int size);
    virtual unsigned int getStack_of_QNodeIndexesArraySize() const;
    virtual int getStack_of_QNodeIndexes(unsigned int k) const;
    virtual void setStack_of_QNodeIndexes(unsigned int k, int stack_of_QNodeIndexes);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const ConnectionSetupResponse& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, ConnectionSetupResponse& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:153</tt> by nedtool.
 * <pre>
 * packet BSMtimingNotifier extends header
 * {
 *     simtime_t timing_at;
 *     int accepted_photons_per_sec;
 *     double interval;
 *     int number_of_qubits;
 *     int internal_qnic_index = -1;
 *     int internal_qnic_address = -1;
 * }
 * </pre>
 */
class BSMtimingNotifier : public ::quisp::messages::header
{
  protected:
    ::omnetpp::simtime_t timing_at;
    int accepted_photons_per_sec;
    double interval;
    int number_of_qubits;
    int internal_qnic_index;
    int internal_qnic_address;

  private:
    void copy(const BSMtimingNotifier& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BSMtimingNotifier&);

  public:
    BSMtimingNotifier(const char *name=nullptr, short kind=0);
    BSMtimingNotifier(const BSMtimingNotifier& other);
    virtual ~BSMtimingNotifier();
    BSMtimingNotifier& operator=(const BSMtimingNotifier& other);
    virtual BSMtimingNotifier *dup() const override {return new BSMtimingNotifier(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual ::omnetpp::simtime_t getTiming_at() const;
    virtual void setTiming_at(::omnetpp::simtime_t timing_at);
    virtual int getAccepted_photons_per_sec() const;
    virtual void setAccepted_photons_per_sec(int accepted_photons_per_sec);
    virtual double getInterval() const;
    virtual void setInterval(double interval);
    virtual int getNumber_of_qubits() const;
    virtual void setNumber_of_qubits(int number_of_qubits);
    virtual int getInternal_qnic_index() const;
    virtual void setInternal_qnic_index(int internal_qnic_index);
    virtual int getInternal_qnic_address() const;
    virtual void setInternal_qnic_address(int internal_qnic_address);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BSMtimingNotifier& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BSMtimingNotifier& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:163</tt> by nedtool.
 * <pre>
 * packet BSAtimeoutChecker extends header
 * {
 *     double trial_id;
 * }
 * </pre>
 */
class BSAtimeoutChecker : public ::quisp::messages::header
{
  protected:
    double trial_id;

  private:
    void copy(const BSAtimeoutChecker& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BSAtimeoutChecker&);

  public:
    BSAtimeoutChecker(const char *name=nullptr, short kind=0);
    BSAtimeoutChecker(const BSAtimeoutChecker& other);
    virtual ~BSAtimeoutChecker();
    BSAtimeoutChecker& operator=(const BSAtimeoutChecker& other);
    virtual BSAtimeoutChecker *dup() const override {return new BSAtimeoutChecker(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual double getTrial_id() const;
    virtual void setTrial_id(double trial_id);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BSAtimeoutChecker& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BSAtimeoutChecker& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:167</tt> by nedtool.
 * <pre>
 * packet BSAstart extends header
 * {
 * }
 * </pre>
 */
class BSAstart : public ::quisp::messages::header
{
  protected:

  private:
    void copy(const BSAstart& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BSAstart&);

  public:
    BSAstart(const char *name=nullptr, short kind=0);
    BSAstart(const BSAstart& other);
    virtual ~BSAstart();
    BSAstart& operator=(const BSAstart& other);
    virtual BSAstart *dup() const override {return new BSAstart(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BSAstart& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BSAstart& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:170</tt> by nedtool.
 * <pre>
 * packet EPPStimingNotifier extends header
 * {
 *     simtime_t timing_at;
 *     double interval;
 *     int number_of_qubits;
 *     int internal_qnic = -1;
 * }
 * </pre>
 */
class EPPStimingNotifier : public ::quisp::messages::header
{
  protected:
    ::omnetpp::simtime_t timing_at;
    double interval;
    int number_of_qubits;
    int internal_qnic;

  private:
    void copy(const EPPStimingNotifier& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EPPStimingNotifier&);

  public:
    EPPStimingNotifier(const char *name=nullptr, short kind=0);
    EPPStimingNotifier(const EPPStimingNotifier& other);
    virtual ~EPPStimingNotifier();
    EPPStimingNotifier& operator=(const EPPStimingNotifier& other);
    virtual EPPStimingNotifier *dup() const override {return new EPPStimingNotifier(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual ::omnetpp::simtime_t getTiming_at() const;
    virtual void setTiming_at(::omnetpp::simtime_t timing_at);
    virtual double getInterval() const;
    virtual void setInterval(double interval);
    virtual int getNumber_of_qubits() const;
    virtual void setNumber_of_qubits(int number_of_qubits);
    virtual int getInternal_qnic() const;
    virtual void setInternal_qnic(int internal_qnic);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EPPStimingNotifier& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EPPStimingNotifier& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:178</tt> by nedtool.
 * <pre>
 * packet EmitPhotonRequest extends header
 * {
 *     int qubit_index;
 *     int qnic_index;
 *     int qnic_address;
 *     int qnic_type;
 *     bool receiver;
 *     bool first;
 *     bool last;
 *     int trial;
 * }
 * </pre>
 */
class EmitPhotonRequest : public ::quisp::messages::header
{
  protected:
    int qubit_index;
    int qnic_index;
    int qnic_address;
    int qnic_type;
    bool receiver;
    bool first;
    bool last;
    int trial;

  private:
    void copy(const EmitPhotonRequest& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const EmitPhotonRequest&);

  public:
    EmitPhotonRequest(const char *name=nullptr, short kind=0);
    EmitPhotonRequest(const EmitPhotonRequest& other);
    virtual ~EmitPhotonRequest();
    EmitPhotonRequest& operator=(const EmitPhotonRequest& other);
    virtual EmitPhotonRequest *dup() const override {return new EmitPhotonRequest(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getQubit_index() const;
    virtual void setQubit_index(int qubit_index);
    virtual int getQnic_index() const;
    virtual void setQnic_index(int qnic_index);
    virtual int getQnic_address() const;
    virtual void setQnic_address(int qnic_address);
    virtual int getQnic_type() const;
    virtual void setQnic_type(int qnic_type);
    virtual bool getReceiver() const;
    virtual void setReceiver(bool receiver);
    virtual bool getFirst() const;
    virtual void setFirst(bool first);
    virtual bool getLast() const;
    virtual void setLast(bool last);
    virtual int getTrial() const;
    virtual void setTrial(int trial);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EmitPhotonRequest& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EmitPhotonRequest& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:190</tt> by nedtool.
 * <pre>
 * packet SchedulePhotonTransmissionsOnebyOne extends header
 * {
 *     int qnic_index = -1;
 *     int qnic_address;
 *     int num_sent = 0;
 *     int number_of_qubits_to_send;
 *     int trial;
 *     double interval;
 *     simtime_t timing;
 *     int internal_hom = 0;
 * }
 * </pre>
 */
class SchedulePhotonTransmissionsOnebyOne : public ::quisp::messages::header
{
  protected:
    int qnic_index;
    int qnic_address;
    int num_sent;
    int number_of_qubits_to_send;
    int trial;
    double interval;
    ::omnetpp::simtime_t timing;
    int internal_hom;

  private:
    void copy(const SchedulePhotonTransmissionsOnebyOne& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SchedulePhotonTransmissionsOnebyOne&);

  public:
    SchedulePhotonTransmissionsOnebyOne(const char *name=nullptr, short kind=0);
    SchedulePhotonTransmissionsOnebyOne(const SchedulePhotonTransmissionsOnebyOne& other);
    virtual ~SchedulePhotonTransmissionsOnebyOne();
    SchedulePhotonTransmissionsOnebyOne& operator=(const SchedulePhotonTransmissionsOnebyOne& other);
    virtual SchedulePhotonTransmissionsOnebyOne *dup() const override {return new SchedulePhotonTransmissionsOnebyOne(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getQnic_index() const;
    virtual void setQnic_index(int qnic_index);
    virtual int getQnic_address() const;
    virtual void setQnic_address(int qnic_address);
    virtual int getNum_sent() const;
    virtual void setNum_sent(int num_sent);
    virtual int getNumber_of_qubits_to_send() const;
    virtual void setNumber_of_qubits_to_send(int number_of_qubits_to_send);
    virtual int getTrial() const;
    virtual void setTrial(int trial);
    virtual double getInterval() const;
    virtual void setInterval(double interval);
    virtual ::omnetpp::simtime_t getTiming() const;
    virtual void setTiming(::omnetpp::simtime_t timing);
    virtual int getInternal_hom() const;
    virtual void setInternal_hom(int internal_hom);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SchedulePhotonTransmissionsOnebyOne& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SchedulePhotonTransmissionsOnebyOne& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:202</tt> by nedtool.
 * <pre>
 * packet BSAresult extends header
 * {
 *     bool entangled;
 * 
 * }
 * </pre>
 */
class BSAresult : public ::quisp::messages::header
{
  protected:
    bool entangled;

  private:
    void copy(const BSAresult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BSAresult&);

  public:
    BSAresult(const char *name=nullptr, short kind=0);
    BSAresult(const BSAresult& other);
    virtual ~BSAresult();
    BSAresult& operator=(const BSAresult& other);
    virtual BSAresult *dup() const override {return new BSAresult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEntangled() const;
    virtual void setEntangled(bool entangled);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BSAresult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BSAresult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:207</tt> by nedtool.
 * <pre>
 * packet BSAfinish extends header
 * {
 *     bool entangled;
 * 
 * }
 * </pre>
 */
class BSAfinish : public ::quisp::messages::header
{
  protected:
    bool entangled;

  private:
    void copy(const BSAfinish& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BSAfinish&);

  public:
    BSAfinish(const char *name=nullptr, short kind=0);
    BSAfinish(const BSAfinish& other);
    virtual ~BSAfinish();
    BSAfinish& operator=(const BSAfinish& other);
    virtual BSAfinish *dup() const override {return new BSAfinish(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual bool getEntangled() const;
    virtual void setEntangled(bool entangled);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const BSAfinish& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, BSAfinish& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:214</tt> by nedtool.
 * <pre>
 * //Used for MIM and MM. BSA results are sent back to the neighboring nodes, together with the timing notifier
 * packet CombinedBSAresults extends BSMtimingNotifier
 * {
 *     bool list_of_failed[];
 * }
 * </pre>
 */
class CombinedBSAresults : public ::quisp::messages::BSMtimingNotifier
{
  protected:
    bool *list_of_failed; // array ptr
    unsigned int list_of_failed_arraysize;

  private:
    void copy(const CombinedBSAresults& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CombinedBSAresults&);

  public:
    CombinedBSAresults(const char *name=nullptr, short kind=0);
    CombinedBSAresults(const CombinedBSAresults& other);
    virtual ~CombinedBSAresults();
    CombinedBSAresults& operator=(const CombinedBSAresults& other);
    virtual CombinedBSAresults *dup() const override {return new CombinedBSAresults(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setList_of_failedArraySize(unsigned int size);
    virtual unsigned int getList_of_failedArraySize() const;
    virtual bool getList_of_failed(unsigned int k) const;
    virtual void setList_of_failed(unsigned int k, bool list_of_failed);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CombinedBSAresults& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CombinedBSAresults& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:220</tt> by nedtool.
 * <pre>
 * //Used for MSM. BSA results are sent back to EPPS. EPPS will generate the next order based on that.
 * packet CombinedBSAresults_epps extends header
 * {
 *     bool list_of_failed[];
 * }
 * </pre>
 */
class CombinedBSAresults_epps : public ::quisp::messages::header
{
  protected:
    bool *list_of_failed; // array ptr
    unsigned int list_of_failed_arraysize;

  private:
    void copy(const CombinedBSAresults_epps& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const CombinedBSAresults_epps&);

  public:
    CombinedBSAresults_epps(const char *name=nullptr, short kind=0);
    CombinedBSAresults_epps(const CombinedBSAresults_epps& other);
    virtual ~CombinedBSAresults_epps();
    CombinedBSAresults_epps& operator=(const CombinedBSAresults_epps& other);
    virtual CombinedBSAresults_epps *dup() const override {return new CombinedBSAresults_epps(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual void setList_of_failedArraySize(unsigned int size);
    virtual unsigned int getList_of_failedArraySize() const;
    virtual bool getList_of_failed(unsigned int k) const;
    virtual void setList_of_failed(unsigned int k, bool list_of_failed);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const CombinedBSAresults_epps& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, CombinedBSAresults_epps& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:225</tt> by nedtool.
 * <pre>
 * packet Error extends header
 * {
 *     string error_text;
 * }
 * </pre>
 */
class Error : public ::quisp::messages::header
{
  protected:
    ::omnetpp::opp_string error_text;

  private:
    void copy(const Error& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const Error&);

  public:
    Error(const char *name=nullptr, short kind=0);
    Error(const Error& other);
    virtual ~Error();
    Error& operator=(const Error& other);
    virtual Error *dup() const override {return new Error(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getError_text() const;
    virtual void setError_text(const char * error_text);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const Error& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, Error& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:229</tt> by nedtool.
 * <pre>
 * packet StopEmitting extends header
 * {
 *     int qnic_address;
 * 
 * }
 * </pre>
 */
class StopEmitting : public ::quisp::messages::header
{
  protected:
    int qnic_address;

  private:
    void copy(const StopEmitting& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const StopEmitting&);

  public:
    StopEmitting(const char *name=nullptr, short kind=0);
    StopEmitting(const StopEmitting& other);
    virtual ~StopEmitting();
    StopEmitting& operator=(const StopEmitting& other);
    virtual StopEmitting *dup() const override {return new StopEmitting(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual int getQnic_address() const;
    virtual void setQnic_address(int qnic_address);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const StopEmitting& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, StopEmitting& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:234</tt> by nedtool.
 * <pre>
 * packet SwappingResult extends header
 * {
 *     unsigned long RuleSet_id;
 *     int Rule_id;
 *     int action_index;
 * 
 *     int left_Dest;
 *     int right_Dest;
 * 
 *     int new_partner_left;
 *     int new_partner_qnic_index_left;
 *     int new_partner_qnic_address_left;
 *     int measured_qubit_index_left;
 *     QNIC_type new_partner_qnic_type_left;
 * 
 *     int new_partner_right;
 *     int new_partner_qnic_index_right;
 *     int new_partner_qnic_address_right;
 *     int measured_qubit_index_right;
 *     QNIC_type new_partner_qnic_type_right;
 * 
 *     int operation_type_left;
 *     int operation_type_right;
 * 
 *     int operation_type; // when this would reach the destination
 *     int new_partner;
 *     int new_partner_qnic_index;
 *     int new_partner_qnic_address;
 *     int measured_qubit_index;
 *     QNIC_type new_partner_qnic_type;
 * }
 * </pre>
 */
class SwappingResult : public ::quisp::messages::header
{
  protected:
    unsigned long RuleSet_id;
    int Rule_id;
    int action_index;
    int left_Dest;
    int right_Dest;
    int new_partner_left;
    int new_partner_qnic_index_left;
    int new_partner_qnic_address_left;
    int measured_qubit_index_left;
    QNIC_type new_partner_qnic_type_left;
    int new_partner_right;
    int new_partner_qnic_index_right;
    int new_partner_qnic_address_right;
    int measured_qubit_index_right;
    QNIC_type new_partner_qnic_type_right;
    int operation_type_left;
    int operation_type_right;
    int operation_type;
    int new_partner;
    int new_partner_qnic_index;
    int new_partner_qnic_address;
    int measured_qubit_index;
    QNIC_type new_partner_qnic_type;

  private:
    void copy(const SwappingResult& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const SwappingResult&);

  public:
    SwappingResult(const char *name=nullptr, short kind=0);
    SwappingResult(const SwappingResult& other);
    virtual ~SwappingResult();
    SwappingResult& operator=(const SwappingResult& other);
    virtual SwappingResult *dup() const override {return new SwappingResult(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned long getRuleSet_id() const;
    virtual void setRuleSet_id(unsigned long RuleSet_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int Rule_id);
    virtual int getAction_index() const;
    virtual void setAction_index(int action_index);
    virtual int getLeft_Dest() const;
    virtual void setLeft_Dest(int left_Dest);
    virtual int getRight_Dest() const;
    virtual void setRight_Dest(int right_Dest);
    virtual int getNew_partner_left() const;
    virtual void setNew_partner_left(int new_partner_left);
    virtual int getNew_partner_qnic_index_left() const;
    virtual void setNew_partner_qnic_index_left(int new_partner_qnic_index_left);
    virtual int getNew_partner_qnic_address_left() const;
    virtual void setNew_partner_qnic_address_left(int new_partner_qnic_address_left);
    virtual int getMeasured_qubit_index_left() const;
    virtual void setMeasured_qubit_index_left(int measured_qubit_index_left);
    virtual QNIC_type& getNew_partner_qnic_type_left();
    virtual const QNIC_type& getNew_partner_qnic_type_left() const {return const_cast<SwappingResult*>(this)->getNew_partner_qnic_type_left();}
    virtual void setNew_partner_qnic_type_left(const QNIC_type& new_partner_qnic_type_left);
    virtual int getNew_partner_right() const;
    virtual void setNew_partner_right(int new_partner_right);
    virtual int getNew_partner_qnic_index_right() const;
    virtual void setNew_partner_qnic_index_right(int new_partner_qnic_index_right);
    virtual int getNew_partner_qnic_address_right() const;
    virtual void setNew_partner_qnic_address_right(int new_partner_qnic_address_right);
    virtual int getMeasured_qubit_index_right() const;
    virtual void setMeasured_qubit_index_right(int measured_qubit_index_right);
    virtual QNIC_type& getNew_partner_qnic_type_right();
    virtual const QNIC_type& getNew_partner_qnic_type_right() const {return const_cast<SwappingResult*>(this)->getNew_partner_qnic_type_right();}
    virtual void setNew_partner_qnic_type_right(const QNIC_type& new_partner_qnic_type_right);
    virtual int getOperation_type_left() const;
    virtual void setOperation_type_left(int operation_type_left);
    virtual int getOperation_type_right() const;
    virtual void setOperation_type_right(int operation_type_right);
    virtual int getOperation_type() const;
    virtual void setOperation_type(int operation_type);
    virtual int getNew_partner() const;
    virtual void setNew_partner(int new_partner);
    virtual int getNew_partner_qnic_index() const;
    virtual void setNew_partner_qnic_index(int new_partner_qnic_index);
    virtual int getNew_partner_qnic_address() const;
    virtual void setNew_partner_qnic_address(int new_partner_qnic_address);
    virtual int getMeasured_qubit_index() const;
    virtual void setMeasured_qubit_index(int measured_qubit_index);
    virtual QNIC_type& getNew_partner_qnic_type();
    virtual const QNIC_type& getNew_partner_qnic_type() const {return const_cast<SwappingResult*>(this)->getNew_partner_qnic_type();}
    virtual void setNew_partner_qnic_type(const QNIC_type& new_partner_qnic_type);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SwappingResult& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SwappingResult& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:265</tt> by nedtool.
 * <pre>
 * packet InternalRuleSetForwarding extends header
 * {
 *     unsigned long RuleSet_id;
 *     int Rule_id;
 * 
 *     RuleSetField RuleSet;
 * }
 * </pre>
 */
class InternalRuleSetForwarding : public ::quisp::messages::header
{
  protected:
    unsigned long RuleSet_id;
    int Rule_id;
    RuleSetField RuleSet;

  private:
    void copy(const InternalRuleSetForwarding& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InternalRuleSetForwarding&);

  public:
    InternalRuleSetForwarding(const char *name=nullptr, short kind=0);
    InternalRuleSetForwarding(const InternalRuleSetForwarding& other);
    virtual ~InternalRuleSetForwarding();
    InternalRuleSetForwarding& operator=(const InternalRuleSetForwarding& other);
    virtual InternalRuleSetForwarding *dup() const override {return new InternalRuleSetForwarding(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned long getRuleSet_id() const;
    virtual void setRuleSet_id(unsigned long RuleSet_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int Rule_id);
    virtual RuleSetField& getRuleSet();
    virtual const RuleSetField& getRuleSet() const {return const_cast<InternalRuleSetForwarding*>(this)->getRuleSet();}
    virtual void setRuleSet(const RuleSetField& RuleSet);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InternalRuleSetForwarding& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InternalRuleSetForwarding& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>classical_messages.msg:272</tt> by nedtool.
 * <pre>
 * packet InternalRuleSetForwarding_Application extends header
 * {
 *     unsigned long RuleSet_id;
 *     int Rule_id;
 *     int application_type;
 * 
 *     RuleSetField RuleSet;
 * }
 * </pre>
 */
class InternalRuleSetForwarding_Application : public ::quisp::messages::header
{
  protected:
    unsigned long RuleSet_id;
    int Rule_id;
    int application_type;
    RuleSetField RuleSet;

  private:
    void copy(const InternalRuleSetForwarding_Application& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const InternalRuleSetForwarding_Application&);

  public:
    InternalRuleSetForwarding_Application(const char *name=nullptr, short kind=0);
    InternalRuleSetForwarding_Application(const InternalRuleSetForwarding_Application& other);
    virtual ~InternalRuleSetForwarding_Application();
    InternalRuleSetForwarding_Application& operator=(const InternalRuleSetForwarding_Application& other);
    virtual InternalRuleSetForwarding_Application *dup() const override {return new InternalRuleSetForwarding_Application(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual unsigned long getRuleSet_id() const;
    virtual void setRuleSet_id(unsigned long RuleSet_id);
    virtual int getRule_id() const;
    virtual void setRule_id(int Rule_id);
    virtual int getApplication_type() const;
    virtual void setApplication_type(int application_type);
    virtual RuleSetField& getRuleSet();
    virtual const RuleSetField& getRuleSet() const {return const_cast<InternalRuleSetForwarding_Application*>(this)->getRuleSet();}
    virtual void setRuleSet(const RuleSetField& RuleSet);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const InternalRuleSetForwarding_Application& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, InternalRuleSetForwarding_Application& obj) {obj.parsimUnpack(b);}

} // namespace messages
} // namespace quisp

#endif // ifndef __QUISP__MESSAGES_CLASSICAL_MESSAGES_M_H

