//
// Generated file, do not edit! Created by nedtool 5.6 from PhotonicQubit.msg.
//

#ifndef __QUISP__MESSAGES_PHOTONICQUBIT_M_H
#define __QUISP__MESSAGES_PHOTONICQUBIT_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// nedtool version check
#define MSGC_VERSION 0x0506
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of nedtool: 'make clean' should help.
#endif

// cplusplus {{
 
    #include <vector>
    #include <unsupported/Eigen/MatrixFunctions>

	using namespace omnetpp;
    typedef cModule *GOD_statQubitPtr; 
    
// }}


namespace quisp {
namespace messages {

/**
 * Class generated from <tt>PhotonicQubit.msg:17</tt> by nedtool.
 * <pre>
 * message PhotonicQubit
 * {
 *     \@customize(true);
 *     string message_type = "qubit";
 *     //int SrcAddr = -1;
 *     //int DestAddr = -1;
 *     bool pauliXerr = false;
 *     bool pauliZerr = false;
 *     bool photonLost = false;
 *     bool nonPaulierr = false;
 *     bool nonPaulierrTwo = false;
 *     int NodeEntangledWith = -1;//Which node it is entangled with. -1 if not entangled. Equivalent to SrcAddress.
 *     int QNICEntangledWith = -1;//Which QNIC it is entangled with
 *     int StationaryQubitEntangledWith = -1;//Which buffer it is entangled with
 *     GOD_statQubitPtr entangled_with;
 *     int QNICtypeEntangledWith = -1;
 *     //cModulePtr qnic_pointer;
 *     //EntangledWith entangledWith;
 *     double error_random_for_debug;
 *     bool first = false;
 *     bool last = false;
 * }
 * </pre>
 *
 * PhotonicQubit_Base is only useful if it gets subclassed, and PhotonicQubit is derived from it.
 * The minimum code to be written for PhotonicQubit is the following:
 *
 * <pre>
 * class PhotonicQubit : public PhotonicQubit_Base
 * {
 *   private:
 *     void copy(const PhotonicQubit& other) { ... }

 *   public:
 *     PhotonicQubit(const char *name=nullptr, short kind=0) : PhotonicQubit_Base(name,kind) {}
 *     PhotonicQubit(const PhotonicQubit& other) : PhotonicQubit_Base(other) {copy(other);}
 *     PhotonicQubit& operator=(const PhotonicQubit& other) {if (this==&other) return *this; PhotonicQubit_Base::operator=(other); copy(other); return *this;}
 *     virtual PhotonicQubit *dup() const override {return new PhotonicQubit(*this);}
 *     // ADD CODE HERE to redefine and implement pure virtual functions from PhotonicQubit_Base
 * };
 * </pre>
 *
 * The following should go into a .cc (.cpp) file:
 *
 * <pre>
 * Register_Class(PhotonicQubit)
 * </pre>
 */
class PhotonicQubit_Base : public ::omnetpp::cMessage
{
  protected:
    ::omnetpp::opp_string message_type;
    bool pauliXerr;
    bool pauliZerr;
    bool photonLost;
    bool nonPaulierr;
    bool nonPaulierrTwo;
    int NodeEntangledWith;
    int QNICEntangledWith;
    int StationaryQubitEntangledWith;
    GOD_statQubitPtr entangled_with;
    int QNICtypeEntangledWith;
    double error_random_for_debug;
    bool first;
    bool last;

  private:
    void copy(const PhotonicQubit_Base& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PhotonicQubit_Base&);
    // make constructors protected to avoid instantiation
    PhotonicQubit_Base(const char *name=nullptr, short kind=0);
    PhotonicQubit_Base(const PhotonicQubit_Base& other);
    // make assignment operator protected to force the user override it
    PhotonicQubit_Base& operator=(const PhotonicQubit_Base& other);

  public:
    virtual ~PhotonicQubit_Base();
    virtual PhotonicQubit_Base *dup() const override {throw omnetpp::cRuntimeError("You forgot to manually add a dup() function to class PhotonicQubit");}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    // field getter/setter methods
    virtual const char * getMessage_type() const;
    virtual void setMessage_type(const char * message_type);
    virtual bool getPauliXerr() const;
    virtual void setPauliXerr(bool pauliXerr);
    virtual bool getPauliZerr() const;
    virtual void setPauliZerr(bool pauliZerr);
    virtual bool getPhotonLost() const;
    virtual void setPhotonLost(bool photonLost);
    virtual bool getNonPaulierr() const;
    virtual void setNonPaulierr(bool nonPaulierr);
    virtual bool getNonPaulierrTwo() const;
    virtual void setNonPaulierrTwo(bool nonPaulierrTwo);
    virtual int getNodeEntangledWith() const;
    virtual void setNodeEntangledWith(int NodeEntangledWith);
    virtual int getQNICEntangledWith() const;
    virtual void setQNICEntangledWith(int QNICEntangledWith);
    virtual int getStationaryQubitEntangledWith() const;
    virtual void setStationaryQubitEntangledWith(int StationaryQubitEntangledWith);
    virtual GOD_statQubitPtr& getEntangled_with();
    virtual const GOD_statQubitPtr& getEntangled_with() const {return const_cast<PhotonicQubit_Base*>(this)->getEntangled_with();}
    virtual void setEntangled_with(const GOD_statQubitPtr& entangled_with);
    virtual int getQNICtypeEntangledWith() const;
    virtual void setQNICtypeEntangledWith(int QNICtypeEntangledWith);
    virtual double getError_random_for_debug() const;
    virtual void setError_random_for_debug(double error_random_for_debug);
    virtual bool getFirst() const;
    virtual void setFirst(bool first);
    virtual bool getLast() const;
    virtual void setLast(bool last);
};

// cplusplus {{
    class PhotonicQubit : public PhotonicQubit_Base
	{
  		public:
    			PhotonicQubit(const char *name=nullptr) : PhotonicQubit_Base(name) {}
    			PhotonicQubit(const PhotonicQubit& other) : PhotonicQubit_Base(other) {}
    			PhotonicQubit& operator=(const PhotonicQubit& other)
        		{PhotonicQubit_Base::operator=(other); return *this;}
    			virtual PhotonicQubit *dup() const {return new PhotonicQubit(*this);}

	};Register_Class(PhotonicQubit);
	
// }}

} // namespace messages
} // namespace quisp

#endif // ifndef __QUISP__MESSAGES_PHOTONICQUBIT_M_H

